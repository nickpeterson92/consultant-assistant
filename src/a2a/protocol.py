"""Agent-to-Agent (A2A) protocol implementation using JSON-RPC 2.0.

Provides resilient inter-agent communication with connection pooling,
circuit breakers, and retry logic.
"""

import json
import uuid
import asyncio
import time
import traceback
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
import aiohttp
from aiohttp import web
from src.utils.config import (
    A2A_STATUS_PENDING,
    DEFAULT_A2A_PORT, DEFAULT_HOST
)
import logging

from src.utils.logging import get_logger
# No input validation needed - trust agent-generated content
from src.utils.message_serialization import serialize_message
from .circuit_breaker import CircuitBreakerConfig, RetryConfig, resilient_call
from src.utils.config import config

# Initialize structured logger
logger = get_logger()

@dataclass  
class TimestampedBase:
    """Base class for dataclasses that need automatic timestamp initialization."""
    created_at: Optional[str] = None
    
    def __post_init__(self):
        """Initialize timestamp if not provided."""
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc).isoformat()


@dataclass
class AgentCard:
    """Agent capability manifest for discovery and routing."""
    name: str
    version: str
    description: str
    capabilities: List[str]
    endpoints: Dict[str, str]
    communication_modes: List[str]
    metadata: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return asdict(self)

@dataclass
class A2ATask:
    """Task entity for agent processing with context and state."""
    id: str
    instruction: str
    context: Dict[str, Any]
    state_snapshot: Dict[str, Any]
    status: str = A2A_STATUS_PENDING  # Status values from constants
    created_at: Optional[str] = None
    
    def __post_init__(self):
        """Initialize timestamp if not provided."""
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization.
        
        Uses centralized message serialization utility for LangChain objects.
        """
        try:
            # Try standard asdict first - should work if all objects are serialized
            return asdict(self)
        except (TypeError, ValueError):
            # Fallback: manually serialize any LangChain objects using centralized utility
            result = {
                "id": self.id,
                "instruction": self.instruction,
                "status": self.status,
                "created_at": self.created_at,
                "context": self._serialize_dict_with_messages(self.context),
                "state_snapshot": self._serialize_dict_with_messages(self.state_snapshot)
            }
            return result
    
    def _serialize_dict_with_messages(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Helper to serialize dictionaries using centralized message serialization."""
        if not isinstance(data, dict):
            return data
        
        result = data.copy()
        
        # Handle recent_messages using centralized utility
        if "recent_messages" in result and isinstance(result["recent_messages"], list):
            result["recent_messages"] = [serialize_message(msg) for msg in result["recent_messages"]]
        
        # Handle messages field (for state_snapshot) using centralized utility
        if "messages" in result and isinstance(result["messages"], list):
            result["messages"] = [serialize_message(msg) for msg in result["messages"]]
        
        return result

@dataclass
class A2AArtifact:
    """Immutable output generated by an agent.
    
    Artifacts represent the concrete results of agent processing.
    They are immutable to ensure data integrity and provide a clear
    audit trail. The content can be any serializable data structure,
    with content_type indicating how to interpret it.
    
    Attributes:
        id: Unique identifier for the artifact
        task_id: Links artifact to the task that generated it
        content: The actual output data (text, structured data, etc.)
        content_type: MIME type or custom type identifier
        metadata: Additional context about the artifact
        created_at: ISO timestamp for ordering and audit
    """
    id: str
    task_id: str
    content: Any
    content_type: str
    metadata: Optional[Dict[str, Any]] = None
    created_at: Optional[str] = None
    
    def __post_init__(self):
        """Initialize timestamp if not provided."""
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return asdict(self)

@dataclass
class A2AMessage:
    """Message for inter-agent communication.
    
    Messages enable agents to communicate during task processing,
    supporting patterns like clarification requests, status updates,
    and partial results. This supports more complex multi-turn
    interactions between agents.
    
    Attributes:
        id: Unique message identifier
        task_id: Links message to ongoing task
        content: Message body (typically natural language)
        sender: Agent identifier that sent the message
        recipient: Target agent identifier
        message_type: Semantic type for message routing/handling
        metadata: Additional routing or processing hints
        created_at: ISO timestamp for message ordering
    """
    id: str
    task_id: str
    content: str
    sender: str
    recipient: str
    message_type: str = "instruction"  # instruction, response, status
    metadata: Optional[Dict[str, Any]] = None
    created_at: Optional[str] = None
    
    def __post_init__(self):
        """Initialize timestamp if not provided."""
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return asdict(self)

class A2ARequest:
    """JSON-RPC 2.0 request wrapper.
    
    Encapsulates requests in the standard JSON-RPC 2.0 format, providing:
    - Consistent request structure across all agent communications
    - Request/response correlation through unique IDs
    - Clear method routing and parameter passing
    
    The JSON-RPC 2.0 standard was chosen for its simplicity, wide support,
    and well-defined error handling semantics.
    """
    
    def __init__(self, method: str, params: Dict[str, Any], request_id: Optional[str] = None):
        """Initialize a JSON-RPC request.
        
        Args:
            method: RPC method name to invoke
            params: Method parameters as a dictionary
            request_id: Optional correlation ID (auto-generated if not provided)
        """
        self.jsonrpc = "2.0"
        self.method = method
        self.params = params
        self.id = request_id or str(uuid.uuid4())
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to JSON-RPC 2.0 request format."""
        return {
            "jsonrpc": self.jsonrpc,
            "method": self.method,
            "params": self.params,
            "id": self.id
        }

class A2AResponse:
    """JSON-RPC 2.0 response wrapper.
    
    Encapsulates responses in the standard JSON-RPC 2.0 format, supporting
    both successful results and structured error responses. The mutual
    exclusivity of result/error fields provides clear success/failure
    semantics.
    
    Error codes follow JSON-RPC 2.0 specification:
    - -32700: Parse error
    - -32600: Invalid request
    - -32601: Method not found
    - -32602: Invalid params
    - -32603: Internal error
    """
    
    def __init__(self, result: Any = None, error: Optional[Dict[str, Any]] = None, request_id: Optional[str] = None):
        """Initialize a JSON-RPC response.
        
        Args:
            result: Successful result data (mutually exclusive with error)
            error: Error object with code, message, and optional data
            request_id: Correlation ID from the request
        """
        self.jsonrpc = "2.0"
        self.result = result
        self.error = error
        self.id = request_id
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to JSON-RPC 2.0 response format."""
        response = {
            "jsonrpc": self.jsonrpc,
            "id": self.id
        }
        if self.error:
            response["error"] = self.error
        else:
            response["result"] = self.result
        return response

class A2AConnectionPool:
    """Singleton connection pool for efficient HTTP session reuse.
    
    This implementation addresses several key performance concerns:
    
    1. Connection Reuse: HTTP connections are expensive to establish,
       especially with TLS. Reusing connections dramatically reduces
       latency for subsequent requests.
    
    2. Resource Management: Prevents connection exhaustion by limiting
       total connections and connections per host. The high per-host
       limit (20+) supports parallel tool execution patterns.
    
    3. Idle Cleanup: Automatically closes idle connections to free
       resources while maintaining hot connections for active agents.
    
    4. Thread Safety: Uses asyncio locks to ensure safe concurrent
       access to the pool from multiple coroutines.
    
    Design decisions:
    - Singleton pattern ensures global connection sharing
    - Per-endpoint locking prevents race conditions
    - Configurable timeouts support different latency requirements
    - DNS caching reduces lookup overhead for repeated requests
    """
    _instance = None
    _lock = asyncio.Lock()
    
    def __new__(cls):
        """Ensure single instance (singleton pattern)."""
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        """Initialize the connection pool with configuration."""
        if not hasattr(self, '_initialized'):
            self._initialized = True
            self._pools = {}  # endpoint -> session
            self._pool_locks = {}  # endpoint -> lock
            self._last_used = {}  # endpoint -> timestamp
            a2a_config = config
            self._max_idle_time = a2a_config.get('a2a.connection_pool_max_idle', 300)
            logger.info("connection_pool_initialized",
                component="a2a",
                operation="init",
                max_idle_time=self._max_idle_time
            )
    
    async def get_session(self, endpoint: str, timeout: Optional[int] = None) -> aiohttp.ClientSession:
        """Get or create a session for an endpoint.
        
        This method implements session reuse with proper lifecycle management:
        - Reuses existing sessions when available (fast path)
        - Creates new sessions with optimized settings when needed
        - Tracks last usage for idle timeout management
        - Uses per-endpoint locking to prevent race conditions
        
        Args:
            endpoint: Full URL of the target endpoint
            timeout: Optional custom timeout (uses config default if not specified)
            
        Returns:
            aiohttp.ClientSession configured for the endpoint
        """
        a2a_config = config
        if timeout is None:
            timeout = a2a_config.get('a2a.timeout', 60)
        
        # Extract base URL to pool connections by host
        from urllib.parse import urlparse
        parsed = urlparse(endpoint)
        base_url = f"{parsed.scheme}://{parsed.netloc}"
        
        # Include timeout in the pool key to avoid timeout mismatches
        pool_key = f"{base_url}_timeout_{timeout}"
        
        # Lazy lock creation avoids pre-allocating for all possible endpoints
        if pool_key not in self._pool_locks:
            self._pool_locks[pool_key] = asyncio.Lock()
        
        async with self._pool_locks[pool_key]:
            # Fast path: reuse existing session
            if pool_key in self._pools:
                session = self._pools[pool_key]
                if not session.closed:
                    self._last_used[pool_key] = time.time()
                    return session
                else:
                    logger.info("removing_closed_session",
                        component="a2a",
                        operation="get_session",
                        pool_key=pool_key
                    )
                    del self._pools[pool_key]
            
            # Create new session with optimized settings
            logger.info("creating_new_session",
                component="a2a",
                operation="get_session",
                base_url=base_url,
                timeout=timeout
            )
            
            # Multi-level timeout configuration for fine-grained control:
            # - total: Overall request timeout
            # - connect: TCP connection establishment  
            # - sock_read/connect: Lower-level socket timeouts
            timeout_config = aiohttp.ClientTimeout(
                total=timeout,
                connect=a2a_config.get('a2a.connect_timeout', 30),
                sock_read=a2a_config.get('a2a.sock_read_timeout', 60),
                sock_connect=a2a_config.get('a2a.sock_connect_timeout', 30)
            )
            
            # Log the actual timeout values for debugging
            logger.info("timeout_config",
                component="a2a",
                operation="get_session",
                total_timeout=timeout,
                connect_timeout=a2a_config.get('a2a.connect_timeout', 30),
                sock_read_timeout=a2a_config.get('a2a.sock_read_timeout', 60),
                sock_connect_timeout=a2a_config.get('a2a.sock_connect_timeout', 30)
            )
            
            # Connection pooling configuration optimized for agent workloads:
            # - High per-host limit supports parallel tool execution (8+ concurrent)
            # - DNS caching reduces repeated lookups for agent endpoints
            # - Keepalive maintains persistent connections for low latency
            # - Cleanup removes stale connections automatically
            connector = aiohttp.TCPConnector(
                limit=a2a_config.get('a2a.connection_pool_size', 20),
                limit_per_host=max(a2a_config.get('a2a.min_connections_per_host', 20), a2a_config.get('a2a.connection_pool_size', 20)),
                ttl_dns_cache=a2a_config.get('a2a.connection_pool_ttl', 300),
                enable_cleanup_closed=True,
                force_close=False,
                keepalive_timeout=min(30, a2a_config.get('a2a.connection_pool_max_idle', 300))
            )
            
            session = aiohttp.ClientSession(
                timeout=timeout_config,
                connector=connector,
                connector_owner=True  # Session owns connector lifecycle
            )
            
            self._pools[pool_key] = session
            self._last_used[pool_key] = time.time()
            return session
    
    async def cleanup_idle_sessions(self):
        """Clean up idle sessions to free resources.
        
        This method should be called periodically (e.g., every minute) to:
        - Free memory and file descriptors from unused connections
        - Prevent connection leaks from accumulating over time
        - Ensure fresh connections for infrequently used agents
        
        The two-phase approach (collect then remove) avoids modifying
        the dictionary while iterating.
        """
        current_time = time.time()
        to_remove = []
        
        # Phase 1: Identify idle sessions
        for endpoint, last_used in self._last_used.items():
            if current_time - last_used > self._max_idle_time:
                to_remove.append(endpoint)
        
        # Phase 2: Remove idle sessions with proper locking
        for endpoint in to_remove:
            async with self._pool_locks[endpoint]:
                if endpoint in self._pools:
                    session = self._pools[endpoint]
                    await session.close()
                    del self._pools[endpoint]
                    del self._last_used[endpoint]
                    logger.info("idle_session_cleaned",
                        component="a2a",
                        operation="cleanup_idle_sessions",
                        endpoint=endpoint
                    )
    
    async def close_all(self):
        """Close all sessions in the pool.
        
        Called during shutdown to ensure clean resource cleanup.
        Uses defensive programming to handle sessions that may
        already be closed or in an error state.
        """
        for endpoint, session in list(self._pools.items()):
            try:
                await session.close()
                logger.info("session_closed",
                    component="a2a",
                    operation="close_all",
                    endpoint=endpoint
                )
            except Exception as e:
                # Log but don't fail - session may already be closed
                logger.warning("session_close_error",
                    component="a2a",
                    operation="close_all",
                    endpoint=endpoint,
                    error=str(e),
                    error_type=type(e).__name__
                )
        self._pools.clear()
        self._last_used.clear()

# Global connection pool instance - lazy initialization pattern
_connection_pool = None

def get_connection_pool() -> A2AConnectionPool:
    """Get the global connection pool instance.
    
    Uses lazy initialization to avoid creating the pool until
    it's actually needed, which helps with testing and reduces
    startup overhead.
    """
    global _connection_pool
    if _connection_pool is None:
        _connection_pool = A2AConnectionPool()
    return _connection_pool

class A2AClient:
    """Client for resilient agent-to-agent communication.
    
    Features connection pooling, circuit breakers, and retry logic.
    """
    
    def __init__(self, timeout: Optional[int] = None, use_pool: bool = True):
        """Initialize the A2A client.
        
        Args:
            timeout: Request timeout in seconds (uses config default if None)
            use_pool: Whether to use connection pooling (True for production)
        """
        a2a_config = config
        system_config = config
        
        self.timeout = timeout if timeout is not None else a2a_config.get('a2a.timeout', 60)
        self.use_pool = use_pool
        self.session = None
        self._closed = False
        self._pool = get_connection_pool() if use_pool else None
        logger.info("a2a_client_initialized",
            component="a2a",
            operation="init",
            timeout=self.timeout,
            use_pool=use_pool
        )
    
    async def __aenter__(self):
        if not self.use_pool:
            # Get config settings
            a2a_config = config
            # Create dedicated session if not using pool
            timeout_config = aiohttp.ClientTimeout(
                total=self.timeout,
                connect=a2a_config.get('a2a.connect_timeout', 30),
                sock_read=a2a_config.get('a2a.sock_read_timeout', 60),
                sock_connect=a2a_config.get('a2a.sock_connect_timeout', 30)
            )
            connector = aiohttp.TCPConnector(
                limit=a2a_config.get('a2a.connection_pool_size', 20),
                limit_per_host=max(a2a_config.get('a2a.min_connections_per_host', 20), a2a_config.get('a2a.connection_pool_size', 20)),  # Allow many concurrent connections per host (support 8+ tools)
                ttl_dns_cache=a2a_config.get('a2a.connection_pool_ttl', 300)
            )
            self.session = aiohttp.ClientSession(
                timeout=timeout_config,
                connector=connector
            )
            logger.info("dedicated_session_created",
                component="a2a",
                operation="create_session",
                timeout=self.timeout
            )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()
    
    async def close(self):
        """Properly close the client session"""
        if not self.use_pool and self.session and not self._closed:
            try:
                await self.session.close()
                logger.info("Closed dedicated A2A client session")
            except Exception as e:
                logger.warning("client_close_error",
                    component="a2a",
                    operation="close",
                    error=str(e),
                    error_type=type(e).__name__
                )
            finally:
                self._closed = True
                self.session = None
    
    async def _make_raw_call(self, endpoint: str, method: str, params: Dict[str, Any], request_id: Optional[str] = None) -> Dict[str, Any]:
        """Make a raw JSON-RPC call without resilience patterns.
        
        This is the core communication method that handles:
        - Request/response serialization in JSON-RPC 2.0 format
        - Connection management (pooled or dedicated)
        - Comprehensive logging for observability
        - Error handling with proper exception types
        
        The method is wrapped by call_agent() which adds resilience patterns.
        
        Args:
            endpoint: Full URL of the agent endpoint
            method: JSON-RPC method name to invoke
            params: Method parameters as dictionary
            request_id: Optional correlation ID
            
        Returns:
            Dictionary containing the agent's response
            
        Raises:
            A2AException: For protocol-level errors
            asyncio.TimeoutError: For timeout errors
        """        # Generate unique operation ID for correlation across logs
        operation_id = f"a2a_call_{uuid.uuid4().hex[:8]}"

        # Log to multiple systems for comprehensive observability
        logger.info("A2A_CALL_START".lower(), component="a2a", operation_id=operation_id,
                        endpoint=endpoint,
                        method=method,
                        params_keys=list(params.keys()))
        
        # External logging with safe fallback
        try:

            # Session management with pooling optimization
            if self.use_pool:
                # Pooled mode: efficient connection reuse
                session = await self._pool.get_session(endpoint, self.timeout)
            else:
                # Dedicated mode: isolated session for testing
                if not self.session or self._closed:
                    logger.error("Client session not initialized or already closed")
                    raise RuntimeError("Client must be used as async context manager and not closed")
                session = self.session

            request = A2ARequest(method, params, request_id)
            request_dict = request.to_dict()

            start_time = time.time()
            logger.info("a2a_request_start",
                component="a2a",
                operation="make_raw_call",
                endpoint=endpoint,
                timeout=self.timeout,
                pooled=self.use_pool,
                method=method
            )
            
            # Make HTTP POST request
            # Note: Timeout is already configured at the session level
            # Avoid duplicate timeout parameter to prevent Python 3.13 compatibility issues
            async with session.post(
                endpoint,
                json=request_dict,
                headers={"Content-Type": "application/json"}
            ) as response:
                elapsed = time.time() - start_time
                logger.info("a2a_response_received",
                    component="a2a",
                    operation="make_raw_call",
                    endpoint=endpoint,
                    elapsed_seconds=round(elapsed, 2),
                    status_code=response.status
                )
                if response.status != 200:
                    error_text = await response.text()
                    logger.error("a2a_http_error",
                        component="a2a",
                        operation="make_raw_call",
                        status_code=response.status,
                        error_text=error_text,
                        endpoint=endpoint
                    )
                    raise A2AException(f"HTTP {response.status}: {error_text}")

                result = await response.json()

                # Check for JSON-RPC error response
                if "error" in result:
                    logger.error("agent_error_response",
                        component="a2a",
                        operation="make_raw_call",
                        error=result['error'],
                        endpoint=endpoint
                    )
                    raise A2AException(f"Agent error: {result['error']}")

                final_result = result.get("result", {})

                # Track performance metrics for successful calls
                duration = None
                logger.info("a2a_call_success",
                    component="a2a",
                    operation="make_raw_call",
                    method=method,
                    endpoint=endpoint
                )
                # Log completion
                logger.info("A2A_CALL_SUCCESS".lower(), component="a2a", operation_id=operation_id,
                                endpoint=endpoint,
                                method=method,
                                result_keys=list(final_result.keys()),
                                artifacts_count=len(final_result.get('artifacts', [])))

                return final_result

        except asyncio.TimeoutError as e:
            # Timeout errors are common in distributed systems - handle gracefully
            # with clear error messages for debugging
            elapsed = time.time() - start_time if 'start_time' in locals() else 0
            logger.error("a2a_timeout_error",
                component="a2a",
                operation="make_raw_call",
                endpoint=endpoint,
                elapsed_seconds=round(elapsed, 2),
                configured_timeout=self.timeout,
                session_timeout=session.timeout if 'session' in locals() else 'unknown'
            )
            raise A2AException(f"Request timed out after {elapsed:.2f}s")
        except aiohttp.ClientError as e:
            # Network errors include connection failures, DNS issues, etc.
            # These are often transient and will be retried by the resilience layer
            elapsed = time.time() - start_time if 'start_time' in locals() else 0
            logger.error("a2a_network_error",
                component="a2a",
                operation="make_raw_call",
                endpoint=endpoint,
                elapsed_seconds=round(elapsed, 2),
                error=str(e),
                error_type=type(e).__name__
            )
            
            # Special handling for shutdown scenarios to avoid noisy errors
            if not self.use_pool and self._closed:
                logger.info("Ignoring network error during client shutdown")
                return {"error": "Client shutdown during operation"}
            else:
                raise A2AException(f"Network error: {str(e)}")
        except Exception as e:
            # Log unexpected error
            logger.error("a2a_unexpected_error",
                component="a2a",
                operation="make_raw_call",
                error_type=type(e).__name__,
                error=str(e)
            )
            raise
    
    async def call_agent(self, endpoint: str, method: str, params: Dict[str, Any], request_id: Optional[str] = None) -> Dict[str, Any]:
        """Make a JSON-RPC call with circuit breaker and retry logic.
        
        Args:
            endpoint: Full URL of the agent endpoint
            method: JSON-RPC method name to invoke
            params: Method parameters as dictionary
            request_id: Optional correlation ID
            
        Returns:
            Dictionary containing the agent's response
            
        Raises:
            A2AException: After all retry attempts are exhausted
        """
        a2a_config = config
        
        # Configure circuit breaker for fast failure detection
        circuit_config = CircuitBreakerConfig(
            failure_threshold=a2a_config.get('a2a.circuit_breaker_threshold', 5),
            timeout=a2a_config.get('a2a.circuit_breaker_timeout', 30),
            half_open_max_calls=3
        )
        
        # Configure retry for transient failure recovery
        retry_config = RetryConfig(
            max_attempts=a2a_config.get('a2a.retry_attempts', 3),
            base_delay=a2a_config.get('a2a.retry_delay', 1.0),
            max_delay=30.0
        )
        
        # Create unique circuit breaker per agent+method combination
        # This prevents one broken method from affecting others
        agent_name = endpoint.split('/')[2].replace(':', '_')  # Convert host:port to host_port
        circuit_breaker_name = f"a2a_{agent_name}_{method}"
        
        try:
            return await resilient_call(
                self._make_raw_call,
                circuit_breaker_name,
                retry_config,
                circuit_config,
                endpoint, method, params, request_id
            )
        except Exception as e:
            logger.error("resilient_call_failed",
                component="a2a",
                operation="call_agent",
                error=str(e),
                error_type=type(e).__name__
            )
            raise
    
    async def process_task(self, endpoint: str, task: A2ATask) -> Dict[str, Any]:
        """Process a task with another agent.
        
        This is the primary method for agent-to-agent task delegation.
        It serializes the task and sends it to the target agent for processing.
        
        Args:
            endpoint: Full URL of the agent endpoint
            task: A2ATask object containing instruction and context
            
        Returns:
            Dictionary with task results and artifacts
        """
        # Log task processing start
        logger.info("a2a_task_start",
            component="a2a",
            operation="process_task",
            task_id=task.id,
            endpoint=endpoint,
            instruction_preview=task.instruction[:100] if task.instruction else "",
            context_size=len(str(task.context)) if task.context else 0,
            has_artifacts=False,  # A2ATask doesn't have artifacts attribute
            has_state_snapshot=bool(task.state_snapshot)
        )
        
        try:
            result = await self.call_agent(
                endpoint=endpoint,
                method="process_task",
                params={"task": task.to_dict()}
            )
            
            # Log successful task completion
            logger.info("a2a_task_complete",
                component="a2a",
                operation="process_task",
                task_id=task.id,
                endpoint=endpoint,
                result_keys=list(result.keys()) if isinstance(result, dict) else [],
                success=True
            )
            
            return result
        except Exception as e:
            # Log task failure
            logger.error("a2a_task_error",
                component="a2a",
                operation="process_task",
                task_id=task.id,
                endpoint=endpoint,
                error=str(e),
                error_type=type(e).__name__
            )
            raise
    
    async def get_agent_card(self, endpoint: str) -> AgentCard:
        """Retrieve agent capabilities for discovery.
        
        Used by the orchestrator to understand what an agent can do
        without hardcoding knowledge about specific agents.
        
        Args:
            endpoint: Full URL of the agent endpoint
            
        Returns:
            AgentCard describing the agent's capabilities
        """
        result = await self.call_agent(
            endpoint=endpoint,
            method="get_agent_card",
            params={}
        )
        return AgentCard(**result)

class A2AServer:
    """A2A Protocol Server for handling incoming agent requests.
    
    This server implements the receiving side of the A2A protocol,
    handling JSON-RPC 2.0 requests from other agents. Key features:
    
    1. Standards Compliance: Strict JSON-RPC 2.0 implementation
    2. Input Validation: Protects against malformed or malicious requests  
    3. Method Registration: Flexible handler registration pattern
    4. Agent Card Endpoint: Self-description for discovery
    5. Error Handling: Proper error codes and messages per spec
    
    The server is designed to be embedded in agent implementations,
    providing a consistent communication interface across all agents.
    """
    
    def __init__(self, agent_card: AgentCard, host: str = DEFAULT_HOST, port: int = DEFAULT_A2A_PORT):
        """Initialize the A2A server.
        
        Args:
            agent_card: Self-description of this agent's capabilities
            host: Host to bind to (0.0.0.0 for all interfaces)
            port: Port to listen on
        """
        self.agent_card = agent_card
        self.host = host
        self.port = port
        self.app = web.Application()
        self.handlers = {}
        self._setup_routes()
    
    def _setup_routes(self):
        """Set up HTTP routes for A2A protocol endpoints."""
        self.app.router.add_post("/a2a", self._handle_request)
        self.app.router.add_get("/a2a/agent-card", self._handle_agent_card)
    
    def register_handler(self, method: str, handler):
        """Register a handler for a JSON-RPC method.
        
        Args:
            method: JSON-RPC method name
            handler: Async function that processes the method
        """
        self.handlers[method] = handler
    
    async def _handle_agent_card(self, request: web.Request) -> web.Response:
        """Return agent card for capability discovery.
        
        This endpoint allows other agents and the orchestrator to
        discover what this agent can do without prior knowledge.
        """
        return web.json_response(self.agent_card.to_dict())
    
    async def _handle_request(self, request: web.Request) -> web.Response:
        """Handle incoming JSON-RPC requests.
        
        This method implements comprehensive request handling with:
        - Input validation to prevent injection attacks
        - Proper error responses per JSON-RPC 2.0 spec
        - Method dispatch to registered handlers
        - Structured error handling with appropriate status codes
        
        Error codes follow JSON-RPC 2.0 specification:
        - -32700: Parse error (malformed JSON)
        - -32600: Invalid request (wrong structure)
        - -32601: Method not found
        - -32602: Invalid params
        - -32603: Internal error
        """
        try:
            data = await request.json()
            
            # Type validation prevents processing non-dict payloads
            if not isinstance(data, dict):
                return web.json_response(
                    A2AResponse(error={"code": -32600, "message": "Invalid Request - must be object"}).to_dict(),
                    status=400
                )
            
            # Validate JSON-RPC 2.0 format
            if data.get("jsonrpc") != "2.0":
                return web.json_response(
                    A2AResponse(error={"code": -32600, "message": "Invalid Request"}).to_dict(),
                    status=400
                )
            
            method = data.get("method")
            params = data.get("params", {})
            request_id = data.get("id")
            
            # Method name validation prevents excessive memory usage
            if not isinstance(method, str) or len(method) > 100:
                return web.json_response(
                    A2AResponse(error={"code": -32600, "message": "Invalid method name"}, request_id=request_id).to_dict(),
                    status=400
                )
            
            # Params must be object (dict) per our A2A implementation
            if not isinstance(params, dict):
                return web.json_response(
                    A2AResponse(error={"code": -32600, "message": "Invalid params - must be object"}, request_id=request_id).to_dict(),
                    status=400
                )
            
            # No validation needed - trust agent-generated task data
            # Agents communicate with well-formed JSON-RPC messages
            
            if method not in self.handlers:
                return web.json_response(
                    A2AResponse(error={"code": -32601, "message": "Method not found"}, request_id=request_id).to_dict(),
                    status=404
                )
            
            # Dispatch to registered handler
            try:
                result = await self.handlers[method](params)
                response = A2AResponse(result=result, request_id=request_id)
                return web.json_response(response.to_dict())
            
            except Exception as e:
                # Handler exceptions are logged but sanitized in response
                logger.error("handler_error",
                    component="a2a",
                    operation="handle_request",
                    method=method,
                    error=str(e),
                    error_type=type(e).__name__,
                    traceback=traceback.format_exc()
                )
                response = A2AResponse(
                    error={"code": -32603, "message": "Internal error", "data": str(e)},
                    request_id=request_id
                )
                return web.json_response(response.to_dict(), status=500)
        
        except json.JSONDecodeError:
            # Malformed JSON gets parse error response
            return web.json_response(
                A2AResponse(error={"code": -32700, "message": "Parse error"}).to_dict(),
                status=400
            )
        except Exception as e:
            # Catch-all for unexpected errors - log but don't leak details
            logger.error("unexpected_request_error",
                component="a2a",
                operation="handle_request",
                error=str(e),
                error_type=type(e).__name__,
                traceback=traceback.format_exc()
            )
            return web.json_response(
                A2AResponse(error={"code": -32603, "message": "Internal error"}).to_dict(),
                status=500
            )
    
    async def start(self):
        """Start the A2A server.
        
        Returns:
            AppRunner instance for lifecycle management
        """
        runner = web.AppRunner(self.app)
        await runner.setup()
        
        site = web.TCPSite(runner, self.host, self.port)
        await site.start()
        
        logger.info(f"A2A Server started on {self.host}:{self.port}")
        return runner
    
    async def stop(self, runner):
        """Stop the A2A server gracefully.
        
        Args:
            runner: AppRunner instance from start()
        """
        await runner.cleanup()

class A2AException(Exception):
    """Custom exception for A2A protocol errors.
    
    Used to distinguish protocol-level errors from other exceptions,
    enabling proper error handling and retry logic in the resilience layer.
    """
    pass