"""
Agent2Agent (A2A) Protocol Implementation
Based on Google's A2A specification with JSON-RPC 2.0 over HTTP
"""

import json
import uuid
import asyncio
from typing import Dict, Any, Optional, List, Union
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
import aiohttp
from aiohttp import web
import logging

logger = logging.getLogger(__name__)

@dataclass
class AgentCard:
    """Agent capability description following A2A specification"""
    name: str
    version: str
    description: str
    capabilities: List[str]
    endpoints: Dict[str, str]
    communication_modes: List[str]
    metadata: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

@dataclass
class A2ATask:
    """Stateful collaboration entity"""
    id: str
    instruction: str
    context: Dict[str, Any]
    state_snapshot: Dict[str, Any]
    status: str = "pending"  # pending, in_progress, completed, failed
    created_at: Optional[str] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

@dataclass
class A2AArtifact:
    """Immutable output generated by an agent"""
    id: str
    task_id: str
    content: Any
    content_type: str
    metadata: Optional[Dict[str, Any]] = None
    created_at: Optional[str] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

@dataclass
class A2AMessage:
    """Message for passing context and instructions"""
    id: str
    task_id: str
    content: str
    sender: str
    recipient: str
    message_type: str = "instruction"  # instruction, response, status
    metadata: Optional[Dict[str, Any]] = None
    created_at: Optional[str] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

class A2ARequest:
    """JSON-RPC 2.0 request wrapper"""
    
    def __init__(self, method: str, params: Dict[str, Any], request_id: Optional[str] = None):
        self.jsonrpc = "2.0"
        self.method = method
        self.params = params
        self.id = request_id or str(uuid.uuid4())
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "jsonrpc": self.jsonrpc,
            "method": self.method,
            "params": self.params,
            "id": self.id
        }

class A2AResponse:
    """JSON-RPC 2.0 response wrapper"""
    
    def __init__(self, result: Any = None, error: Optional[Dict[str, Any]] = None, request_id: Optional[str] = None):
        self.jsonrpc = "2.0"
        self.result = result
        self.error = error
        self.id = request_id
    
    def to_dict(self) -> Dict[str, Any]:
        response = {
            "jsonrpc": self.jsonrpc,
            "id": self.id
        }
        if self.error:
            response["error"] = self.error
        else:
            response["result"] = self.result
        return response

class A2AClient:
    """A2A Protocol Client for making calls to other agents"""
    
    def __init__(self, timeout: int = 30, debug_mode: bool = False):
        self.timeout = timeout
        self.debug_mode = debug_mode
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=self.timeout))
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def call_agent(self, endpoint: str, method: str, params: Dict[str, Any], request_id: Optional[str] = None) -> Dict[str, Any]:
        """Make a JSON-RPC call to another agent"""
        try:
            if self.debug_mode:
                logger.info(f"A2A call to {endpoint}: {method}")
                print(f"\nðŸ”¥ A2A CLIENT NUCLEAR DEBUG ðŸ”¥")
                print(f"ðŸ“¡ Calling endpoint: {endpoint}")
                print(f"ðŸ“¡ Method: {method}")
                print(f"ðŸ“¡ Request ID: {request_id}")
                print(f"ðŸ“¡ Params structure: {list(params.keys())}")
                if 'task' in params:
                    task = params['task']
                    print(f"ðŸ“¡ Task ID: {task.get('id')}")
                    print(f"ðŸ“¡ Task instruction: {task.get('instruction')}")
                    print(f"ðŸ“¡ Task context: {task.get('context')}")
                    print(f"ðŸ“¡ Task state_snapshot: {task.get('state_snapshot')}")
            
            if not self.session:
                if self.debug_mode:
                    logger.error("Client session not initialized")
                raise RuntimeError("Client must be used as async context manager")
            
            request = A2ARequest(method, params, request_id)
            request_dict = request.to_dict()
            
            if self.debug_mode:
                print(f"ðŸ“¤ SENDING REQUEST PAYLOAD:")
                print(f"   JSON-RPC version: {request_dict.get('jsonrpc')}")
                print(f"   Method: {request_dict.get('method')}")
                print(f"   ID: {request_dict.get('id')}")
                print(f"   Params keys: {list(request_dict.get('params', {}).keys())}")
                
            async with self.session.post(
                endpoint,
                json=request_dict,
                headers={"Content-Type": "application/json"}
            ) as response:
                if response.status != 200:
                    error_text = await response.text()
                    if self.debug_mode:
                        print(f"âŒ HTTP ERROR {response.status}: {error_text}")
                    logger.error(f"A2A HTTP error {response.status}: {error_text}")
                    raise A2AException(f"HTTP {response.status}: {error_text}")
                
                result = await response.json()
                
                if self.debug_mode:
                    print(f"ðŸ“¥ RECEIVED RESPONSE:")
                    print(f"   Response keys: {list(result.keys())}")
                    print(f"   JSON-RPC version: {result.get('jsonrpc')}")
                    print(f"   ID: {result.get('id')}")
                    if 'result' in result:
                        result_data = result['result']
                        print(f"   Result keys: {list(result_data.keys())}")
                        if 'artifacts' in result_data:
                            artifacts = result_data['artifacts']
                            print(f"   Artifacts count: {len(artifacts) if isinstance(artifacts, list) else 'not list'}")
                            if isinstance(artifacts, list) and artifacts:
                                first_artifact = artifacts[0]
                                print(f"   First artifact keys: {list(first_artifact.keys()) if isinstance(first_artifact, dict) else 'not dict'}")
                                if isinstance(first_artifact, dict) and 'content' in first_artifact:
                                    content = first_artifact['content']
                                    print(f"   Content preview: {str(content)[:200]}...")
                
                if "error" in result:
                    if self.debug_mode:
                        print(f"âŒ AGENT ERROR: {result['error']}")
                    logger.error(f"Agent returned error: {result['error']}")
                    raise A2AException(f"Agent error: {result['error']}")
                
                final_result = result.get("result", {})
                if self.debug_mode:
                    logger.info(f"A2A call success: {method}")
                    print(f"âœ… A2A CALL SUCCESSFUL")
                    print(f"ðŸ”¥ END A2A CLIENT NUCLEAR DEBUG ðŸ”¥\n")
                return final_result
        
        except aiohttp.ClientError as e:
            logger.error(f"A2A network error calling {endpoint}: {e}")
            raise A2AException(f"Network error: {str(e)}")
        except Exception as e:
            logger.error(f"A2A unexpected error: {type(e).__name__}: {e}")
            if self.debug_mode:
                import traceback
                logger.error(f"Traceback: {traceback.format_exc()}")
            raise
    
    async def process_task(self, endpoint: str, task: A2ATask) -> Dict[str, Any]:
        """High-level method to process a task with another agent"""
        return await self.call_agent(
            endpoint=endpoint,
            method="process_task",
            params={"task": task.to_dict()}
        )
    
    async def get_agent_card(self, endpoint: str) -> AgentCard:
        """Retrieve agent capabilities"""
        result = await self.call_agent(
            endpoint=endpoint,
            method="get_agent_card",
            params={}
        )
        return AgentCard(**result)

class A2AServer:
    """A2A Protocol Server for handling requests from other agents"""
    
    def __init__(self, agent_card: AgentCard, host: str = "0.0.0.0", port: int = 8000):
        self.agent_card = agent_card
        self.host = host
        self.port = port
        self.app = web.Application()
        self.handlers = {}
        self._setup_routes()
    
    def _setup_routes(self):
        """Set up HTTP routes for A2A protocol"""
        self.app.router.add_post("/a2a", self._handle_request)
        self.app.router.add_get("/a2a/agent-card", self._handle_agent_card)
    
    def register_handler(self, method: str, handler):
        """Register a method handler"""
        self.handlers[method] = handler
    
    async def _handle_agent_card(self, request: web.Request) -> web.Response:
        """Return agent card (capabilities)"""
        return web.json_response(self.agent_card.to_dict())
    
    async def _handle_request(self, request: web.Request) -> web.Response:
        """Handle JSON-RPC requests"""
        try:
            data = await request.json()
            
            # Validate JSON-RPC format
            if data.get("jsonrpc") != "2.0":
                return web.json_response(
                    A2AResponse(error={"code": -32600, "message": "Invalid Request"}).to_dict(),
                    status=400
                )
            
            method = data.get("method")
            params = data.get("params", {})
            request_id = data.get("id")
            
            if method not in self.handlers:
                return web.json_response(
                    A2AResponse(error={"code": -32601, "message": "Method not found"}, request_id=request_id).to_dict(),
                    status=404
                )
            
            # Call the handler
            try:
                result = await self.handlers[method](params)
                response = A2AResponse(result=result, request_id=request_id)
                return web.json_response(response.to_dict())
            
            except Exception as e:
                logger.exception(f"Handler error for method {method}")
                response = A2AResponse(
                    error={"code": -32603, "message": "Internal error", "data": str(e)},
                    request_id=request_id
                )
                return web.json_response(response.to_dict(), status=500)
        
        except json.JSONDecodeError:
            return web.json_response(
                A2AResponse(error={"code": -32700, "message": "Parse error"}).to_dict(),
                status=400
            )
        except Exception as e:
            logger.exception("Unexpected error in request handler")
            return web.json_response(
                A2AResponse(error={"code": -32603, "message": "Internal error"}).to_dict(),
                status=500
            )
    
    async def start(self):
        """Start the A2A server"""
        runner = web.AppRunner(self.app)
        await runner.setup()
        
        site = web.TCPSite(runner, self.host, self.port)
        await site.start()
        
        logger.info(f"A2A Server started on {self.host}:{self.port}")
        return runner
    
    async def stop(self, runner):
        """Stop the A2A server"""
        await runner.cleanup()

class A2AException(Exception):
    """Custom exception for A2A protocol errors"""
    pass