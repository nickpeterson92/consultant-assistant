"""
Agent2Agent (A2A) Protocol Implementation
Based on Google's A2A specification with JSON-RPC 2.0 over HTTP
"""

import json
import uuid
import asyncio
import time
from typing import Dict, Any, Optional, List, Union
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
import aiohttp
from aiohttp import web
import logging
import sys
import os

# Add logging configuration
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../..'))
from src.utils.logging_config import get_logger, get_performance_tracker


# BULLETPROOF EXTERNAL LOGGING - Direct file writing
import json
from datetime import datetime
from pathlib import Path

def log_a2a_activity(operation_type, **data):
    """Direct external logging that always works"""
    try:
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "operation_type": operation_type,
            **data
        }
        
        # Write to A2A protocol log
        log_file = Path(__file__).parent.parent.parent / "logs" / "a2a_protocol.log"
        log_file.parent.mkdir(exist_ok=True)
        
        with open(log_file, 'a') as f:
            f.write(f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} - a2a_protocol - INFO - {json.dumps(log_entry)}\n")
            f.flush()
            
        # Write to performance log if it's a performance event
        if operation_type in ["A2A_CALL_START", "A2A_CALL_SUCCESS"]:
            perf_file = Path(__file__).parent.parent.parent / "logs" / "performance.log"
            with open(perf_file, 'a') as f:
                f.write(f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} - performance - INFO - {json.dumps(log_entry)}\n")
                f.flush()
    except:
        pass  # Silent fallback

logger = logging.getLogger(__name__)

# Initialize external logging for A2A protocol
# Note: This will be re-initialized at runtime if needed
a2a_logger = None
a2a_perf = None

def ensure_loggers_initialized():
    """Ensure external loggers are properly initialized at runtime"""
    global a2a_logger, a2a_perf
    
    if a2a_logger is None or a2a_perf is None:
        debug_mode = os.environ.get('DEBUG_MODE', 'false').lower() == 'true'
        try:
            a2a_logger = get_logger('a2a_protocol', debug_mode)
            a2a_perf = get_performance_tracker('a2a_protocol', debug_mode)
            # Test log to confirm initialization  
            a2a_logger.info("RUNTIME_LOGGER_INITIALIZED", debug_mode=debug_mode)
        except Exception as e:
            # Silent fallback
            pass

@dataclass
class AgentCard:
    """Agent capability description following A2A specification"""
    name: str
    version: str
    description: str
    capabilities: List[str]
    endpoints: Dict[str, str]
    communication_modes: List[str]
    metadata: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

@dataclass
class A2ATask:
    """Stateful collaboration entity"""
    id: str
    instruction: str
    context: Dict[str, Any]
    state_snapshot: Dict[str, Any]
    status: str = "pending"  # pending, in_progress, completed, failed
    created_at: Optional[str] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

@dataclass
class A2AArtifact:
    """Immutable output generated by an agent"""
    id: str
    task_id: str
    content: Any
    content_type: str
    metadata: Optional[Dict[str, Any]] = None
    created_at: Optional[str] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

@dataclass
class A2AMessage:
    """Message for passing context and instructions"""
    id: str
    task_id: str
    content: str
    sender: str
    recipient: str
    message_type: str = "instruction"  # instruction, response, status
    metadata: Optional[Dict[str, Any]] = None
    created_at: Optional[str] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

class A2ARequest:
    """JSON-RPC 2.0 request wrapper"""
    
    def __init__(self, method: str, params: Dict[str, Any], request_id: Optional[str] = None):
        self.jsonrpc = "2.0"
        self.method = method
        self.params = params
        self.id = request_id or str(uuid.uuid4())
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "jsonrpc": self.jsonrpc,
            "method": self.method,
            "params": self.params,
            "id": self.id
        }

class A2AResponse:
    """JSON-RPC 2.0 response wrapper"""
    
    def __init__(self, result: Any = None, error: Optional[Dict[str, Any]] = None, request_id: Optional[str] = None):
        self.jsonrpc = "2.0"
        self.result = result
        self.error = error
        self.id = request_id
    
    def to_dict(self) -> Dict[str, Any]:
        response = {
            "jsonrpc": self.jsonrpc,
            "id": self.id
        }
        if self.error:
            response["error"] = self.error
        else:
            response["result"] = self.result
        return response

class A2AClient:
    """A2A Protocol Client for making calls to other agents"""
    
    def __init__(self, timeout: int = 30, debug_mode: bool = False):
        self.timeout = timeout
        self.debug_mode = debug_mode
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=self.timeout))
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def call_agent(self, endpoint: str, method: str, params: Dict[str, Any], request_id: Optional[str] = None) -> Dict[str, Any]:
        """Make a JSON-RPC call to another agent"""
        
        # Ensure external loggers are initialized at runtime
        ensure_loggers_initialized()
        
        # Start performance tracking
        operation_id = f"a2a_call_{uuid.uuid4().hex[:8]}"

        # BULLETPROOF EXTERNAL LOGGING
        log_a2a_activity("A2A_CALL_START", 
                        operation_id=operation_id,
                        endpoint=endpoint,
                        method=method,
                        params_keys=list(params.keys()))
        
        # External logging with safe fallback
        if a2a_perf:
            try:
                a2a_perf.start_operation(operation_id, "a2a_call", 
                                        endpoint=endpoint, 
                                        method=method,
                                        request_id=request_id)
            except:
                pass
        
        if a2a_logger:
            try:
                a2a_logger.info("A2A_CALL_START", 
                               operation_id=operation_id,
                               endpoint=endpoint, 
                               method=method,
                               request_id=request_id,
                               params_keys=list(params.keys()))
            except:
                pass
        
        try:
            if self.debug_mode:
                logger.info(f"A2A call to {endpoint}: {method}")
                print(f"\nðŸ”¥ A2A CLIENT NUCLEAR DEBUG ðŸ”¥")
                print(f"ðŸ“¡ Calling endpoint: {endpoint}")
                print(f"ðŸ“¡ Method: {method}")
                print(f"ðŸ“¡ Request ID: {request_id}")
                print(f"ðŸ“¡ Params structure: {list(params.keys())}")
                if 'task' in params:
                    task = params['task']
                    print(f"ðŸ“¡ Task ID: {task.get('id')}")
                    print(f"ðŸ“¡ Task instruction: {task.get('instruction')}")
                    print(f"ðŸ“¡ Task context: {task.get('context')}")
                    print(f"ðŸ“¡ Task state_snapshot: {task.get('state_snapshot')}")

            if not self.session:
                if self.debug_mode:
                    logger.error("Client session not initialized")
                raise RuntimeError("Client must be used as async context manager")

            request = A2ARequest(method, params, request_id)
            request_dict = request.to_dict()

            if self.debug_mode:
                print(f"ðŸ“¤ SENDING REQUEST PAYLOAD:")
                print(f"   JSON-RPC version: {request_dict.get('jsonrpc')}")
                print(f"   Method: {request_dict.get('method')}")
                print(f"   ID: {request_dict.get('id')}")
                print(f"   Params keys: {list(request_dict.get('params', {}).keys())}")

            async with self.session.post(
                endpoint,
                json=request_dict,
                headers={"Content-Type": "application/json"}
            ) as response:
                if response.status != 200:
                    error_text = await response.text()
                    if self.debug_mode:
                        print(f"âŒ HTTP ERROR {response.status}: {error_text}")
                    logger.error(f"A2A HTTP error {response.status}: {error_text}")
                    raise A2AException(f"HTTP {response.status}: {error_text}")

                result = await response.json()

                if self.debug_mode:
                    print(f"ðŸ“¥ RECEIVED RESPONSE:")
                    print(f"   Response keys: {list(result.keys())}")
                    print(f"   JSON-RPC version: {result.get('jsonrpc')}")
                    print(f"   ID: {result.get('id')}")
                    if 'result' in result:
                        result_data = result['result']
                        print(f"   Result keys: {list(result_data.keys())}")
                        if 'artifacts' in result_data:
                            artifacts = result_data['artifacts']
                            print(f"   Artifacts count: {len(artifacts) if isinstance(artifacts, list) else 'not list'}")
                            if isinstance(artifacts, list) and artifacts:
                                first_artifact = artifacts[0]
                                print(f"   First artifact keys: {list(first_artifact.keys()) if isinstance(first_artifact, dict) else 'not dict'}")
                                if isinstance(first_artifact, dict) and 'content' in first_artifact:
                                    content = first_artifact['content']
                                    print(f"   Content preview: {str(content)[:200]}...")

                if "error" in result:
                    if self.debug_mode:
                        print(f"âŒ AGENT ERROR: {result['error']}")
                    logger.error(f"Agent returned error: {result['error']}")
                    raise A2AException(f"Agent error: {result['error']}")

                final_result = result.get("result", {})

                # Log successful completion
                duration = None
                if a2a_perf:
                    try:
                        duration = a2a_perf.end_operation(operation_id, success=True,
                                                         result_keys=list(final_result.keys()),
                                                         artifacts_count=len(final_result.get('artifacts', [])))
                    except:
                        pass

                if a2a_logger:
                    try:
                        a2a_logger.info("A2A_CALL_SUCCESS",
                                       operation_id=operation_id,
                                       endpoint=endpoint,
                                       method=method,
                                       duration_ms=duration*1000 if duration else 0,
                                       result_keys=list(final_result.keys()))
                    except:
                        pass

                if self.debug_mode:
                    logger.info(f"A2A call success: {method}")
                    print(f"âœ… A2A CALL SUCCESSFUL")
                    print(f"ðŸ”¥ END A2A CLIENT NUCLEAR DEBUG ðŸ”¥\n")
                # Log completion
                log_a2a_activity("A2A_CALL_SUCCESS",
                                operation_id=operation_id,
                                endpoint=endpoint,
                                method=method,
                                result_keys=list(final_result.keys()),
                                artifacts_count=len(final_result.get('artifacts', [])))

                return final_result

        except aiohttp.ClientError as e:
            # Log network error
            if a2a_perf:
                try:
                    a2a_perf.end_operation(operation_id, success=False, error_type="network_error")
                except:
                    pass
            if a2a_logger:
                try:
                    a2a_logger.error("A2A_CALL_NETWORK_ERROR",
                                    operation_id=operation_id,
                                    endpoint=endpoint,
                                    error=str(e))
                except:
                    pass
            logger.error(f"A2A network error calling {endpoint}: {e}")
            raise A2AException(f"Network error: {str(e)}")
        except Exception as e:
            # Log unexpected error
            if a2a_perf:
                try:
                    a2a_perf.end_operation(operation_id, success=False, error_type=type(e).__name__)
                except:
                    pass
            if a2a_logger:
                try:
                    a2a_logger.error("A2A_CALL_ERROR",
                                    operation_id=operation_id,
                                    endpoint=endpoint,
                                    error_type=type(e).__name__,
                                    error=str(e))
                except:
                    pass
            logger.error(f"A2A unexpected error: {type(e).__name__}: {e}")
            if self.debug_mode:
                import traceback
                logger.error(f"Traceback: {traceback.format_exc()}")
            raise
    
    async def process_task(self, endpoint: str, task: A2ATask) -> Dict[str, Any]:
        """High-level method to process a task with another agent"""
        return await self.call_agent(
            endpoint=endpoint,
            method="process_task",
            params={"task": task.to_dict()}
        )
    
    async def get_agent_card(self, endpoint: str) -> AgentCard:
        """Retrieve agent capabilities"""
        result = await self.call_agent(
            endpoint=endpoint,
            method="get_agent_card",
            params={}
        )
        return AgentCard(**result)

class A2AServer:
    """A2A Protocol Server for handling requests from other agents"""
    
    def __init__(self, agent_card: AgentCard, host: str = "0.0.0.0", port: int = 8000):
        self.agent_card = agent_card
        self.host = host
        self.port = port
        self.app = web.Application()
        self.handlers = {}
        self._setup_routes()
    
    def _setup_routes(self):
        """Set up HTTP routes for A2A protocol"""
        self.app.router.add_post("/a2a", self._handle_request)
        self.app.router.add_get("/a2a/agent-card", self._handle_agent_card)
    
    def register_handler(self, method: str, handler):
        """Register a method handler"""
        self.handlers[method] = handler
    
    async def _handle_agent_card(self, request: web.Request) -> web.Response:
        """Return agent card (capabilities)"""
        return web.json_response(self.agent_card.to_dict())
    
    async def _handle_request(self, request: web.Request) -> web.Response:
        """Handle JSON-RPC requests"""
        try:
            data = await request.json()
            
            # Validate JSON-RPC format
            if data.get("jsonrpc") != "2.0":
                return web.json_response(
                    A2AResponse(error={"code": -32600, "message": "Invalid Request"}).to_dict(),
                    status=400
                )
            
            method = data.get("method")
            params = data.get("params", {})
            request_id = data.get("id")
            
            if method not in self.handlers:
                return web.json_response(
                    A2AResponse(error={"code": -32601, "message": "Method not found"}, request_id=request_id).to_dict(),
                    status=404
                )
            
            # Call the handler
            try:
                result = await self.handlers[method](params)
                response = A2AResponse(result=result, request_id=request_id)
                return web.json_response(response.to_dict())
            
            except Exception as e:
                logger.exception(f"Handler error for method {method}")
                response = A2AResponse(
                    error={"code": -32603, "message": "Internal error", "data": str(e)},
                    request_id=request_id
                )
                return web.json_response(response.to_dict(), status=500)
        
        except json.JSONDecodeError:
            return web.json_response(
                A2AResponse(error={"code": -32700, "message": "Parse error"}).to_dict(),
                status=400
            )
        except Exception as e:
            logger.exception("Unexpected error in request handler")
            return web.json_response(
                A2AResponse(error={"code": -32603, "message": "Internal error"}).to_dict(),
                status=500
            )
    
    async def start(self):
        """Start the A2A server"""
        runner = web.AppRunner(self.app)
        await runner.setup()
        
        site = web.TCPSite(runner, self.host, self.port)
        await site.start()
        
        logger.info(f"A2A Server started on {self.host}:{self.port}")
        return runner
    
    async def stop(self, runner):
        """Stop the A2A server"""
        await runner.cleanup()

class A2AException(Exception):
    """Custom exception for A2A protocol errors"""
    pass