"""
Agent2Agent (A2A) Protocol Implementation
Based on Google's A2A specification with JSON-RPC 2.0 over HTTP
"""

import json
import uuid
import asyncio
import time
from typing import Dict, Any, Optional, List, Union
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
import aiohttp
from aiohttp import web
import logging
import sys
import os

# Add logging configuration
from src.utils.logging_config import get_logger, get_performance_tracker


# Import centralized logging
from src.utils.activity_logger import log_a2a_activity, log_performance_activity
from src.utils.input_validation import AgentInputValidator, ValidationError
from src.utils.circuit_breaker import get_circuit_breaker, CircuitBreakerConfig, RetryConfig, resilient_call
from src.utils.config import get_a2a_config

# A2A logging now handled by centralized activity_logger

logger = logging.getLogger(__name__)

# Initialize external logging for A2A protocol
# Note: This will be re-initialized at runtime if needed
a2a_logger = None
a2a_perf = None

def ensure_loggers_initialized():
    """Ensure external loggers are properly initialized at runtime"""
    global a2a_logger, a2a_perf
    
    if a2a_logger is None or a2a_perf is None:
        debug_mode = os.environ.get('DEBUG_MODE', 'false').lower() == 'true'
        try:
            a2a_logger = get_logger('a2a_protocol', debug_mode)
            a2a_perf = get_performance_tracker('a2a_protocol', debug_mode)
            # Test log to confirm initialization  
            a2a_logger.info("RUNTIME_LOGGER_INITIALIZED", debug_mode=debug_mode)
        except Exception as e:
            # Silent fallback
            pass

@dataclass
class AgentCard:
    """Agent capability description following A2A specification"""
    name: str
    version: str
    description: str
    capabilities: List[str]
    endpoints: Dict[str, str]
    communication_modes: List[str]
    metadata: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

@dataclass
class A2ATask:
    """Stateful collaboration entity"""
    id: str
    instruction: str
    context: Dict[str, Any]
    state_snapshot: Dict[str, Any]
    status: str = "pending"  # pending, in_progress, completed, failed
    created_at: Optional[str] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

@dataclass
class A2AArtifact:
    """Immutable output generated by an agent"""
    id: str
    task_id: str
    content: Any
    content_type: str
    metadata: Optional[Dict[str, Any]] = None
    created_at: Optional[str] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

@dataclass
class A2AMessage:
    """Message for passing context and instructions"""
    id: str
    task_id: str
    content: str
    sender: str
    recipient: str
    message_type: str = "instruction"  # instruction, response, status
    metadata: Optional[Dict[str, Any]] = None
    created_at: Optional[str] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

class A2ARequest:
    """JSON-RPC 2.0 request wrapper"""
    
    def __init__(self, method: str, params: Dict[str, Any], request_id: Optional[str] = None):
        self.jsonrpc = "2.0"
        self.method = method
        self.params = params
        self.id = request_id or str(uuid.uuid4())
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "jsonrpc": self.jsonrpc,
            "method": self.method,
            "params": self.params,
            "id": self.id
        }

class A2AResponse:
    """JSON-RPC 2.0 response wrapper"""
    
    def __init__(self, result: Any = None, error: Optional[Dict[str, Any]] = None, request_id: Optional[str] = None):
        self.jsonrpc = "2.0"
        self.result = result
        self.error = error
        self.id = request_id
    
    def to_dict(self) -> Dict[str, Any]:
        response = {
            "jsonrpc": self.jsonrpc,
            "id": self.id
        }
        if self.error:
            response["error"] = self.error
        else:
            response["result"] = self.result
        return response

class A2AClient:
    """A2A Protocol Client for making calls to other agents"""
    
    def __init__(self, timeout: int = 30, debug_mode: bool = False):
        self.timeout = timeout
        self.debug_mode = debug_mode
        self.session = None
        self._closed = False
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=self.timeout))
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()
    
    async def close(self):
        """Properly close the client session"""
        if self.session and not self._closed:
            try:
                await self.session.close()
            except Exception as e:
                logger.warning(f"Error closing A2A client session: {e}")
            finally:
                self._closed = True
                self.session = None
    
    async def _make_raw_call(self, endpoint: str, method: str, params: Dict[str, Any], request_id: Optional[str] = None) -> Dict[str, Any]:
        """Make a raw JSON-RPC call without resilience patterns"""
        
        # Ensure external loggers are initialized at runtime
        ensure_loggers_initialized()
        
        # Start performance tracking
        operation_id = f"a2a_call_{uuid.uuid4().hex[:8]}"

        # BULLETPROOF EXTERNAL LOGGING
        log_a2a_activity("A2A_CALL_START", 
                        operation_id=operation_id,
                        endpoint=endpoint,
                        method=method,
                        params_keys=list(params.keys()))
        
        # Also log to performance tracker
        log_performance_activity("A2A_CALL_START",
                                operation_id=operation_id,
                                endpoint=endpoint,
                                method=method,
                                params_keys=list(params.keys()))
        
        # External logging with safe fallback
        if a2a_perf:
            try:
                a2a_perf.start_operation(operation_id, "a2a_call", 
                                        endpoint=endpoint, 
                                        method=method,
                                        request_id=request_id)
            except:
                pass
        
        if a2a_logger:
            try:
                a2a_logger.info("A2A_CALL_START", 
                               operation_id=operation_id,
                               endpoint=endpoint, 
                               method=method,
                               request_id=request_id,
                               params_keys=list(params.keys()))
            except:
                pass
        
        try:
            if self.debug_mode:
                logger.info(f"A2A call to {endpoint}: {method}")
                print(f"\nðŸ”¥ A2A CLIENT NUCLEAR DEBUG ðŸ”¥")
                print(f"ðŸ“¡ Calling endpoint: {endpoint}")
                print(f"ðŸ“¡ Method: {method}")
                print(f"ðŸ“¡ Request ID: {request_id}")
                print(f"ðŸ“¡ Params structure: {list(params.keys())}")
                if 'task' in params:
                    task = params['task']
                    print(f"ðŸ“¡ Task ID: {task.get('id')}")
                    print(f"ðŸ“¡ Task instruction: {task.get('instruction')}")
                    print(f"ðŸ“¡ Task context: {task.get('context')}")
                    print(f"ðŸ“¡ Task state_snapshot: {task.get('state_snapshot')}")

            if not self.session or self._closed:
                if self.debug_mode:
                    logger.error("Client session not initialized or already closed")
                raise RuntimeError("Client must be used as async context manager and not closed")

            request = A2ARequest(method, params, request_id)
            request_dict = request.to_dict()

            if self.debug_mode:
                print(f"ðŸ“¤ SENDING REQUEST PAYLOAD:")
                print(f"   JSON-RPC version: {request_dict.get('jsonrpc')}")
                print(f"   Method: {request_dict.get('method')}")
                print(f"   ID: {request_dict.get('id')}")
                print(f"   Params keys: {list(request_dict.get('params', {}).keys())}")

            async with self.session.post(
                endpoint,
                json=request_dict,
                headers={"Content-Type": "application/json"}
            ) as response:
                if response.status != 200:
                    error_text = await response.text()
                    if self.debug_mode:
                        print(f"âŒ HTTP ERROR {response.status}: {error_text}")
                    logger.error(f"A2A HTTP error {response.status}: {error_text}")
                    raise A2AException(f"HTTP {response.status}: {error_text}")

                result = await response.json()

                if self.debug_mode:
                    print(f"ðŸ“¥ RECEIVED RESPONSE:")
                    print(f"   Response keys: {list(result.keys())}")
                    print(f"   JSON-RPC version: {result.get('jsonrpc')}")
                    print(f"   ID: {result.get('id')}")
                    if 'result' in result:
                        result_data = result['result']
                        print(f"   Result keys: {list(result_data.keys())}")
                        if 'artifacts' in result_data:
                            artifacts = result_data['artifacts']
                            print(f"   Artifacts count: {len(artifacts) if isinstance(artifacts, list) else 'not list'}")
                            if isinstance(artifacts, list) and artifacts:
                                first_artifact = artifacts[0]
                                print(f"   First artifact keys: {list(first_artifact.keys()) if isinstance(first_artifact, dict) else 'not dict'}")
                                if isinstance(first_artifact, dict) and 'content' in first_artifact:
                                    content = first_artifact['content']
                                    print(f"   Content preview: {str(content)[:200]}...")

                if "error" in result:
                    if self.debug_mode:
                        print(f"âŒ AGENT ERROR: {result['error']}")
                    logger.error(f"Agent returned error: {result['error']}")
                    raise A2AException(f"Agent error: {result['error']}")

                final_result = result.get("result", {})

                # Log successful completion
                duration = None
                if a2a_perf:
                    try:
                        duration = a2a_perf.end_operation(operation_id, success=True,
                                                         result_keys=list(final_result.keys()),
                                                         artifacts_count=len(final_result.get('artifacts', [])))
                    except:
                        pass

                if a2a_logger:
                    try:
                        a2a_logger.info("A2A_CALL_SUCCESS",
                                       operation_id=operation_id,
                                       endpoint=endpoint,
                                       method=method,
                                       duration_ms=duration*1000 if duration else 0,
                                       result_keys=list(final_result.keys()))
                    except:
                        pass

                if self.debug_mode:
                    logger.info(f"A2A call success: {method}")
                    print(f"âœ… A2A CALL SUCCESSFUL")
                    print(f"ðŸ”¥ END A2A CLIENT NUCLEAR DEBUG ðŸ”¥\n")
                # Log completion
                log_a2a_activity("A2A_CALL_SUCCESS",
                                operation_id=operation_id,
                                endpoint=endpoint,
                                method=method,
                                result_keys=list(final_result.keys()),
                                artifacts_count=len(final_result.get('artifacts', [])))
                
                # Also log to performance tracker
                log_performance_activity("A2A_CALL_SUCCESS",
                                        operation_id=operation_id,
                                        endpoint=endpoint,
                                        method=method,
                                        result_keys=list(final_result.keys()),
                                        artifacts_count=len(final_result.get('artifacts', [])))

                return final_result

        except aiohttp.ClientError as e:
            # Log network error
            if a2a_perf:
                try:
                    a2a_perf.end_operation(operation_id, success=False, error_type="network_error")
                except:
                    pass
            if a2a_logger:
                try:
                    a2a_logger.error("A2A_CALL_NETWORK_ERROR",
                                    operation_id=operation_id,
                                    endpoint=endpoint,
                                    error=str(e))
                except:
                    pass
            logger.error(f"A2A network error calling {endpoint}: {e}")
            # Don't re-raise if session was closed during shutdown
            if not self._closed:
                raise A2AException(f"Network error: {str(e)}")
            else:
                logger.info("Ignoring network error during client shutdown")
                return {"error": "Client shutdown during operation"}
        except Exception as e:
            # Log unexpected error
            if a2a_perf:
                try:
                    a2a_perf.end_operation(operation_id, success=False, error_type=type(e).__name__)
                except:
                    pass
            if a2a_logger:
                try:
                    a2a_logger.error("A2A_CALL_ERROR",
                                    operation_id=operation_id,
                                    endpoint=endpoint,
                                    error_type=type(e).__name__,
                                    error=str(e))
                except:
                    pass
            logger.error(f"A2A unexpected error: {type(e).__name__}: {e}")
            if self.debug_mode:
                import traceback
                logger.error(f"Traceback: {traceback.format_exc()}")
            raise
    
    async def call_agent(self, endpoint: str, method: str, params: Dict[str, Any], request_id: Optional[str] = None) -> Dict[str, Any]:
        """Make a resilient JSON-RPC call to another agent with circuit breaker and retry"""
        
        # Get configuration
        a2a_config = get_a2a_config()
        
        # Create circuit breaker config from system config
        circuit_config = CircuitBreakerConfig(
            failure_threshold=a2a_config.circuit_breaker_threshold,
            timeout=a2a_config.circuit_breaker_timeout,
            half_open_max_calls=3
        )
        
        # Create retry config from system config
        retry_config = RetryConfig(
            max_attempts=a2a_config.retry_attempts,
            base_delay=a2a_config.retry_delay,
            max_delay=30.0
        )
        
        # Extract agent name from endpoint for circuit breaker naming
        agent_name = endpoint.split('/')[2].replace(':', '_')  # Convert host:port to host_port
        circuit_breaker_name = f"a2a_{agent_name}_{method}"
        
        try:
            return await resilient_call(
                self._make_raw_call,
                circuit_breaker_name,
                retry_config,
                circuit_config,
                endpoint, method, params, request_id
            )
        except Exception as e:
            logger.error(f"Resilient A2A call failed after all retries: {e}")
            raise
    
    async def process_task(self, endpoint: str, task: A2ATask) -> Dict[str, Any]:
        """High-level method to process a task with another agent"""
        return await self.call_agent(
            endpoint=endpoint,
            method="process_task",
            params={"task": task.to_dict()}
        )
    
    async def get_agent_card(self, endpoint: str) -> AgentCard:
        """Retrieve agent capabilities"""
        result = await self.call_agent(
            endpoint=endpoint,
            method="get_agent_card",
            params={}
        )
        return AgentCard(**result)

class A2AServer:
    """A2A Protocol Server for handling requests from other agents"""
    
    def __init__(self, agent_card: AgentCard, host: str = "0.0.0.0", port: int = 8000):
        self.agent_card = agent_card
        self.host = host
        self.port = port
        self.app = web.Application()
        self.handlers = {}
        self._setup_routes()
    
    def _setup_routes(self):
        """Set up HTTP routes for A2A protocol"""
        self.app.router.add_post("/a2a", self._handle_request)
        self.app.router.add_get("/a2a/agent-card", self._handle_agent_card)
    
    def register_handler(self, method: str, handler):
        """Register a method handler"""
        self.handlers[method] = handler
    
    async def _handle_agent_card(self, request: web.Request) -> web.Response:
        """Return agent card (capabilities)"""
        return web.json_response(self.agent_card.to_dict())
    
    async def _handle_request(self, request: web.Request) -> web.Response:
        """Handle JSON-RPC requests"""
        try:
            data = await request.json()
            
            # Input validation for security
            if not isinstance(data, dict):
                return web.json_response(
                    A2AResponse(error={"code": -32600, "message": "Invalid Request - must be object"}).to_dict(),
                    status=400
                )
            
            # Validate JSON-RPC format
            if data.get("jsonrpc") != "2.0":
                return web.json_response(
                    A2AResponse(error={"code": -32600, "message": "Invalid Request"}).to_dict(),
                    status=400
                )
            
            method = data.get("method")
            params = data.get("params", {})
            request_id = data.get("id")
            
            # Validate method name
            if not isinstance(method, str) or len(method) > 100:
                return web.json_response(
                    A2AResponse(error={"code": -32600, "message": "Invalid method name"}, request_id=request_id).to_dict(),
                    status=400
                )
            
            # Validate params
            if not isinstance(params, dict):
                return web.json_response(
                    A2AResponse(error={"code": -32600, "message": "Invalid params - must be object"}, request_id=request_id).to_dict(),
                    status=400
                )
            
            # Validate task data if this is a process_task call
            if method == "process_task" and "task" in params:
                try:
                    validated_task = AgentInputValidator.validate_a2a_task(params["task"])
                    params["task"] = validated_task
                except ValidationError as e:
                    return web.json_response(
                        A2AResponse(error={"code": -32602, "message": f"Invalid task data: {e}"}, request_id=request_id).to_dict(),
                        status=400
                    )
            
            if method not in self.handlers:
                return web.json_response(
                    A2AResponse(error={"code": -32601, "message": "Method not found"}, request_id=request_id).to_dict(),
                    status=404
                )
            
            # Call the handler
            try:
                result = await self.handlers[method](params)
                response = A2AResponse(result=result, request_id=request_id)
                return web.json_response(response.to_dict())
            
            except Exception as e:
                logger.exception(f"Handler error for method {method}")
                response = A2AResponse(
                    error={"code": -32603, "message": "Internal error", "data": str(e)},
                    request_id=request_id
                )
                return web.json_response(response.to_dict(), status=500)
        
        except json.JSONDecodeError:
            return web.json_response(
                A2AResponse(error={"code": -32700, "message": "Parse error"}).to_dict(),
                status=400
            )
        except Exception as e:
            logger.exception("Unexpected error in request handler")
            return web.json_response(
                A2AResponse(error={"code": -32603, "message": "Internal error"}).to_dict(),
                status=500
            )
    
    async def start(self):
        """Start the A2A server"""
        runner = web.AppRunner(self.app)
        await runner.setup()
        
        site = web.TCPSite(runner, self.host, self.port)
        await site.start()
        
        logger.info(f"A2A Server started on {self.host}:{self.port}")
        return runner
    
    async def stop(self, runner):
        """Stop the A2A server"""
        await runner.cleanup()

class A2AException(Exception):
    """Custom exception for A2A protocol errors"""
    pass